\section{Animation}
\label{sec:animation}
Meine letzte große Aufgabe war es, die Simulation anständig und so ruckelfrei wie möglich zu animieren. Einerseits wurden hier unsere Möglichkeiten durch die Framerate des Browsers, andererseits durch die Dauer der Berechnung der einzelnen Koordinatenpunkte limitiert. Trotzdem wollten wir für unsere Simulation eine anständige Art und Weise schaffen, wie man das Tempo selbst einstellen kann.

\subsection{Erste Schritte}
Die ersten Monate des Praktikums hatten wir eine von mir entworfene, aber recht simple Idee für die Animation genutzt: Nach einer bestimmten Anzahl (hier: $1000$) an abgearbeiteten Winkelsequenz $10$ Millisekunden warten; Eine Implementierung dieser Idee ist unten im Pseudocode \ref{alg:anim_simple} verdeutlicht. 

\begin{algorithm}[H]
\caption{Simple Animation}\label{alg:anim_simple}
\begin{algorithmic}[1]
\Require Liste aller Winkelsequenzen $SEQS$
\Ensure $/$
\While{Simulation läuft}
    \For{$i=1$ \textbf{to} $SEQS.length$}
        \State Berechne und zeichne 
        \If{$i \mod 1000 == 0$}
        	\State \texttt{sleep($10$)}  \Comment{Pause für $10$ Millisekunden}
        \EndIf
    \EndFor
\EndWhile
\end{algorithmic}
\end{algorithm}

Diese extrem simple Implementierung hat tatsächlich recht gut funktioniert und wir konnten für den Anfang damit arbeiten, allerdings konnte man so noch nicht die wirkliche Animationsgeschwindigkeit einstellen und es wurde nicht die vorgegebenen Zeiten pro Winkelsequenz berücksichtigt. \\
Deswegen hatte ich darüber nachgedacht, wie man diesen Algorithmus verbessern könnte und hatte nach ein paar Anläufen und mit Hilfe von unserem Tutor eine passende Idee, die ich im Folgenden etwas genauer vorstellen werde. \\

    
\subsection{Finaler Algorithmus}
\label{sec:final_anim}
Nachfolgend werde ich meinen final implementierten Algorithmus vorstellen und dabei auch den folgenden Pseudocode \ref{alg:anim} erläutern, indem die dort genutzten Variablen bei der jeweils textuellen Erklärung annotiert sind: \\
Das Grundprinzip aus meinem vorherigen Algorithmus, nach so und so vielen Schritten eine gewisse Zeit zu warten, habe ich beibehalten. Die wesentliche Veränderung, die ich vorgenommen habe, bestand aus einer Anpassung, nach wie vielen Schritten gewartet wird. Statt einer fixen Anzahl von 1000 Schritten habe ich nun die vorgegebenen Zeiten ($timeInterval$) berücksichtigt und konnte mit diesen und der von uns berechneten Anzahl an benötigten Iterationen pro Winkelsequenz ($num\_iterations$) für jede dieser genannten Sequenzen einen durchschnittlichen Wert ermitteln, der nach einer Iteration geschlafen werden sollte, um am Ende auf den gegeben Zeitwert zu kommen ($sleepTime\_per\_iter$). Dieser Durchschnittswert ist in der Regel sehr klein (Größenordnung $\approx 10^{-2}ms$; sehr abhängig von gegebenen Werten). Daher werden diese Werte mit jeder Iteration akkumuliert ($acc\_sleep$) und nur geschlafen, wenn der aufaddierte Wert größer als eine von der eingestellten Animationsgeschwindigkeit (möglich per in \ref{sec:steering} erwähnten Slider; Variable $animSpeed$) abhängigen Obergrenze ist. Eine weitere wichtige Größe ist die maximale Zeit pro Frame ($frametme$), welche in Millisekunden angegeben ist und sich aus der Bildschirmwiederholungsrate errechnet (hier $60Hz$; also $\frac{1}{60s} \cdot 1000 \approx 16,7ms$). Dieser Wert bestimmt zusammen mit der Animationsgeschwindigkeit die eben erwähnte Obergrenze ($ub$) und ist die Zeit, die gewartet wird. (Hier lag ein Problem, welches ich sehr lange zu Debuggen versucht habe: JavaScript hat als Wartezeit auch die von mir - im Rahmen einer anderen Idee davor - eingestellten $1ms$ akzeptiert, jedoch war es nicht möglich, im Browser auch wirklich nur $1ms$ zu warten; Dies hat dazu geführt, dass die Animation zwar funktioniert hat, jedoch deutlich länger als von mir berechnet gebraucht hat; Deshalb habe ich den Wert auf die $frametime$ gesetzt). \\
Um den berechneten Wert $acc\_sleep$ so genau wie möglich zu gestalten, war es nötig, auch die tatsächlich benötigte Zeit des Algorithmus ($time\_per\_iter$) zu berücksichtigen und die Variable $acc\_sleep$ korrekt aufzuaddieren, was in Zeile 4-8 des Pseudocodes passiert. \\
Schlussendlich müssen noch die aufaddierten Werte im Falle des Wartens zurückgesetzt werden, was in der letzten Zeile 12 geschieht. Der bereits erwähnte Algorithmus ist in dem untenstehenden Pseudocode verdeutlicht: \\

\begin{algorithm}[H]
\caption{Animation}\label{alg:anim}
\begin{algorithmic}[1]
\Require $\begin{array}{l}  
SEQS, num\_iterations, timeInterval, \\  
animSpeed, frametime, acc\_sleep  
\end{array}$
\Ensure $/$
\While{Simulation läuft}
    \For{each Winkelsequenz in $SEQS$}
        \State $sleepTime\_per\_Iter \gets \frac{timeInterval}{num_iterations}$ 
        \State $iter\_startTime \gets$ aktuelle Zeit 
        \State Berechne und zeichne 
        \State $iter\_endTime \gets$ aktuelle Zeit 
        \State $time\_per\_iter = iter\_endTime - iter\_startTime$ 
        \State  $acc\_sleep \gets acc\_sleep + time\_per\_iter$
        \State $ub \gets animSpeed * frametime$
        \If{$acc\_sleep \geq ub$}
        	\State \texttt{sleep($frametime$)} 
        	\State $acc\_sleep \gets acc\_sleep - ub$
        \EndIf
    \EndFor
\EndWhile
\end{algorithmic}
\end{algorithm}