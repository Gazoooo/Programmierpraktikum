<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Simulation - Arduino</title>
    <style>
        body {
            font-size: 20px;
        }

        input[type="file"] {
            font-size: 20px;
            padding: 10px; 
        }

        input[type="checkbox"],
        input[type="radio"] {
            width: 25px;
            height: 25px;
        }
        
        button {
            display: flex;
            font-size: 20px;
            flex-direction: column;
            padding: 10px;
            border-radius: 5px;
        }

        #canvas-container {
            position: relative;
            float: left;
            width: 1910px;
            height: 965px;
            margin-bottom: 20px;
            margin-right: 20px;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        .not_working, .not_working * {
            color: red !important;  
            cursor: not-allowed;  
            opacity: 0.3; 
        }

        #error_logger {
            color: red;
        }
    </style>
</head>

<body>
    <div id="canvas-container">
        <canvas id="gridCanvas" width="1910" height="965" style="border:1px solid #000000;"></canvas>
        <canvas id="bgCanvas" width="1910" height="965" style="border:1px solid #000000;"></canvas>
        <canvas id="fgCanvas" width="1910" height="965" style="border:1px solid #000000;"></canvas>
    </div>

    <div id="simulation-container">
        <h2> Simulation </h2>
        <button type="button" id="start_but" onclick="start()">Start</button>
        <button type="button" id="pause_but" onclick="resume()">Pause/Resume</button>
        <button type="button" id="reset_but" onclick="reset()">Reset</button>
        <input type="checkbox" id="hide_fg_checkbox">Versteck Seile & Stift <br>
        <input type="checkbox" id="hide_grid_checkbox" checked>Versteck Koordinatensystem <br>
        <input type="checkbox" id="stop_on_error_checkbox">Stop on errors <br> 
        
        <input type="range" id="speed_slider" min="0" max="105" step="5"> Adjust Speed: <span id="speed_value"> </span>x <br>
    </div>

    <hr>

    <div id="variablen-container"> 
        <h2> Variablen </h2>
        <input type="range" id="dcoil_slider" min="8" max="32" step="8"> Diameter Coil:  <span id="dcoil_value">  </span> <br>

        <input type="number" id="canvaswidth"> Canvaswidth: <br>
        <input type="number" id="canvasheight"> Canvasheight: <br>
        <input type="number" id="drawwidth"> Drawwidth: <br>
        <input type="number" id="drawheight"> Drawheight: <br>

        <input type="number" id="starting_point_x"> Start x: <br>
        <input type="number" id="starting_point_y"> Start y: <br>
    </div>

    <hr>
       
    <div>
        <h2>Angles-Config</h2>
        <div id="config-container">
            <input type="radio" name="config-angles" id="pre-1"> Use pre-build angles 1
            <input type="radio" name="config-angles" id="pre-2"> Use pre-build angles 2
            <input type="radio" name="config-angles" id="fileContent"> Use fileContent angles
        </div>

        <div> 
            <input type="file" id="fileInput" />
            <p id="angle_info"></p>
        </div>

    </div>

    <hr>

    <div>
        <h2>Logs</h2>
        <p id="update_logger">Processing angleNum: <span id="cur_iter">0</span></p>
        <p id="error_logger"></p>
    </div>

    <script>

    // html elements
    const gridCanvas = document.getElementById("gridCanvas");
    const bgCanvas = document.getElementById("bgCanvas");
    const fgCanvas = document.getElementById("fgCanvas");
    const width_entry = document.getElementById("canvaswidth");
    const heigth_entry = document.getElementById("canvasheight");
    const drawwidth_entry = document.getElementById("drawwidth");
    const drawheight_entry = document.getElementById("drawheight");
    const hide_fg_checkbox = document.getElementById("hide_fg_checkbox");
    const hide_grid_checkbox = document.getElementById("hide_grid_checkbox");
    const stop_on_error_checkbox = document.getElementById("stop_on_error_checkbox");
    const angle_output = document.getElementById("angle_info");
    const fileInput = document.getElementById("fileInput");
    const pre1_checkbox = document.getElementById('pre-1');
    const pre2_checkbox = document.getElementById('pre-2');
    const file_checkbox = document.getElementById('fileContent');
    const start_button = document.getElementById('start_but');
    const pause_button = document.getElementById('pause_but');
    const reset_button = document.getElementById('reset_but');
    const dcoil_slider = document.getElementById("dcoil_slider");
    const starting_point_x_entry = document.getElementById('starting_point_x');
    const starting_point_y_entry = document.getElementById('starting_point_y');
    const speed_slider = document.getElementById('speed_slider');
    let update_logger = document.getElementById('update_logger');
    let error_logger = document.getElementById('error_logger');
    let cur_iter = document.getElementById("cur_iter");
    let dcoil_value = document.getElementById("dcoil_value");

    // hardware
    const DELAY = 1 //ms (would be 0.6, but <1 not sleepable in JS)
    let D_COIL, U_COIL; ////measurements of coil; standard is d=16mm
    let angle_step_size = 1.8 / 16; //min. stepsize the arduino can handle

    //coordinates
    const GRID_SPACING = 100; //mm
    const ORIGIN = [0,0];
    const offset_x_ratio = 63/382; //ratio original Offset (315) Canvaswidth (1910)
    const offset_y_ratio = 41/193; //ratio original Offset (205) Canvasheight (965)
    const drawingWidth_ratio = 128/191;
    const drawingHeight_ratio = 144/193;
    let CANVASWIDTH, CANVASHEIGHT; 
    let WIDTH_DRAWINGAREA, HEIGHT_DRAWINGAREA;
    let OFFSET_X, OFFSET_Y; //upper left start from drawing area
    let coords_motor_A = [0,0];
    let coords_motor_B = [CANVASWIDTH, 0];
    let starting_point_x, starting_point_y;

    //list of tripels (time [ms], leftMotor [degrees], rightMotor [degrees])
    const PRE1_ANGLES = [
        [0,0,0],
        [0,0,0],
        [1000,8613,3376],
        [1000,-8613,-3376],
        [1000,17651,-17651],
        [1000,3376,8613],
        [1000,-12414,12414]
    ]; 

    const PRE2_ANGLES = [
        [1000, 4876, -4461],
        [1000, -4876, 4461],
        [1000, 5730, 2865],
        [1000, -2865, 2865],
        [1000, -2865, -5730]
    ]; 

    // derived vars
    
    let lengthA, lengthB;

    // simulation
    const grid_ctx = gridCanvas.getContext("2d");
    const bg_ctx = bgCanvas.getContext("2d");
    const fg_ctx = fgCanvas.getContext("2d");
    let pause = false;
    let running = false; // Flag to check if update is running
    let pixels = [];
    let c_x, c_y; //coords of pen
    let iter_count = 0; //counter for cur_iter html element
    let amount_angleSeqs = 1; //amount of angle seqs loaded
    let ANGLES; //Array where the angleSeqs are stored
    let to_drawStart; //Angle from top left to start
    let to_begin; //Angle from endpoint to top left

    // run continuous
    let extra_steps;
    let a_is_smaller = true;
    let remainder = 0;
    let angleA;
    let angleB;
    let abs_angleA;
    let abs_angleB; 
    let a_is_negativ;
    let b_is_negativ;
    let smaller_angle;
    let greater_angle;
    let stepAmount_smaller_angle;
    let stepAmount_greater_angle;
    /*##transfer commented out##
    let transferA = 0;
    let transferB = 0;*/
    let resultingRemainder = 0;
    let a_was_negativ = false;
    let b_was_negativ = false;
    let frac_remaining_step = 0;

    // animation
    const framerate = 60;
    const frametime = 1/60 * 1000;
    let timeInterval; //1. ele of each tupel
    let animSpeed = 1; //value higher (-> less sleep calls) -> animation faster
    let time_per_iter = 0; //Time needed for 1 Iteration
    let iter_startTime;
    let iter_endTime;
    let sleepTime_per_Iter; //calculated time for sleep each iter
    let startTime; //starttime of each run
    let endTime; //endtime of each run
    let acc_sleep = 0; //acculumated sleepTime

    // calculates the endpoint from two lines by usig pythagoras
    function calculateEndPoint(s1, s2) {
        c_x = (Math.pow(s1, 2) - Math.pow(s2, 2) + Math.pow(coords_motor_B[0], 2)) / (2 * coords_motor_B[0]);
        c_y = Math.sqrt(Math.pow(s2, 2) - Math.pow((coords_motor_B[0] -c_x), 2))

        if (c_x > OFFSET_X+WIDTH_DRAWINGAREA || c_x < OFFSET_X || c_y > OFFSET_Y+HEIGHT_DRAWINGAREA || c_y < OFFSET_Y) {
            handleError("Warning: Out of Drawing Area");
        }

        if (c_x > CANVASWIDTH || c_x < 0 || c_y > CANVASHEIGHT || c_y < 0) {
            handleError("Error: Out of Bounds");
        }

        return [c_x, c_y];
    }
    
    // gets length of a line depending of the Umdrehungswinkel des Motors
    // angle is degree
    function calc_length(angle, cur_length) {
        let extraLength = angle / 360 * U_COIL;
        return cur_length + extraLength;
    }

    //draws the grid with labels and draw Area
    //origin is (0,0) 
    function drawGrid() {

        //draw Axes
        grid_ctx.strokeStyle = "black";
        grid_ctx.lineWidth = 1;
        // X-Axes
        grid_ctx.beginPath();
        grid_ctx.moveTo(0, 0);
        grid_ctx.lineTo(CANVASWIDTH, 0);
        grid_ctx.stroke();
        // Y-Axes
        grid_ctx.beginPath();
        grid_ctx.moveTo(0, 0);
        grid_ctx.lineTo(0, CANVASHEIGHT);
        grid_ctx.stroke();
        

        //draw helper grid lines
        grid_ctx.lineWidth = 0.5;
        //vertical
        for (let x = 0; x <= CANVASWIDTH; x += GRID_SPACING*0.1) {
            grid_ctx.strokeStyle = "#ccc";
            grid_ctx.beginPath();
            grid_ctx.moveTo(x, 0);
            if (x % GRID_SPACING == 0) { //draw some lines 50% darker
                grid_ctx.strokeStyle = "#666666";
            }
            grid_ctx.lineTo(x, CANVASHEIGHT);
            grid_ctx.stroke();
        }
        //horizontal
        for (let y = 0; y <= CANVASHEIGHT; y += GRID_SPACING*0.1) {
            grid_ctx.strokeStyle = "#ccc";
            grid_ctx.beginPath();
            grid_ctx.moveTo(0, y);
            if (y % GRID_SPACING == 0) { //draw some lines 50% darker
                grid_ctx.strokeStyle = "#666666";
            }
            grid_ctx.lineTo(CANVASWIDTH, y);
            grid_ctx.stroke();
        }
        
        //draw labels
        grid_ctx.fillStyle = "black";
        grid_ctx.font = "12px Arial";
        for (let x = 0; x <= CANVASWIDTH; x += GRID_SPACING) {
            grid_ctx.fillText(x, x, 10);
        }
        for (let y = 0; y <= CANVASHEIGHT; y += GRID_SPACING) {
            grid_ctx.fillText(y, 0, y);
        }

        //draw drawing area
        grid_ctx.lineWidth = 2;
        grid_ctx.strokeStyle = "green";
        grid_ctx.beginPath();
        grid_ctx.strokeRect(OFFSET_X, OFFSET_Y, WIDTH_DRAWINGAREA, HEIGHT_DRAWINGAREA);
    }

    //draw Lines
    function drawForeground(c_x, c_y) {
        fg_ctx.clearRect(0, 0, CANVASWIDTH, CANVASHEIGHT);
        if(hide_fg_checkbox.checked) {
            return;
        }
        // lines
        fg_ctx.beginPath();
        fg_ctx.strokeStyle = 'blue'; 
        fg_ctx.lineWidth = 2;

        // 1. line (start on upper left corner)
        fg_ctx.moveTo(coords_motor_A[0], coords_motor_A[1]);       
        fg_ctx.lineTo(c_x, c_y);

        // 2. line (start on upper right corner)
        fg_ctx.moveTo(coords_motor_B[0], coords_motor_B[1]); 
        fg_ctx.lineTo(c_x, c_y);        
        fg_ctx.stroke();

        // pen
        fg_ctx.beginPath();
        fg_ctx.arc(c_x, c_y, 5, 0, 2 * Math.PI);
        fg_ctx.fillStyle = 'red';
        fg_ctx.fill();
        fg_ctx.stroke();
    }

    //pixel drawed by pen
    function drawBackground(c_x, c_y, color='grey') {
        //pixels.push({c_x, c_y});
        bg_ctx.fillStyle = color;
        bg_ctx.fillRect(c_x, c_y, 1, 1);
    }

    //turn motor A if angle negativ return shorter length
    //both motors turn in the same direction
    function turn_A(length, angle_step_size, a_is_negativ) {
        angle_step_size = a_is_negativ ? (-Math.abs(angle_step_size)) : Math.abs(angle_step_size); 
        return calc_length(angle_step_size, length);
    }
    
    //turn motor B if angle negativ return shorter length
    function turn_B(length, angle_step_size, b_is_negativ) {
        angle_step_size = b_is_negativ ? (-Math.abs(angle_step_size)) : Math.abs(angle_step_size);
        return calc_length(angle_step_size, length);
    }

    //helper method for operateMotors()
    //calcs and returns used values
    function calcParameters(angleA, angleB) {
        //determines
        //smaller and greater angle
        //if angles are negativ or positiv
        abs_angleA = Math.abs(angleA);
        abs_angleB = Math.abs(angleB);
        a_is_smaller = abs_angleA <= abs_angleB; 
        a_was_negativ = a_is_negativ;
        b_was_negativ = b_is_negativ;
        a_is_negativ = angleA < 0;
        b_is_negativ = angleB < 0;
        smaller_angle = Math.min(abs_angleA, abs_angleB);
        greater_angle = Math.max(abs_angleA, abs_angleB);
        
        
        /* ############ Transfer for presumably more accurate drawing with less error overall ############
        ## commented out to approximate Arduino hardware solution better ##  
        //if there is a sign switch the transfer of the last angle pair has to be negativ 
        if(a_was_negativ != a_is_negativ) {
            transferA = -transferA;
        }
        if(b_was_negativ != b_is_negativ) {
            transferB = -transferB;
        }
        
        //add remaining fractual step of former iteration   
        //calculate stepAmount for each motor and add the fractual step to the transfer
        if(a_is_smaller) {
            stepAmount_smaller_angle = smaller_angle/Math.abs(angle_step_size) + transferA;
            stepAmount_greater_angle = greater_angle/Math.abs(angle_step_size) + transferB;
            transferA = stepAmount_smaller_angle - Math.floor(stepAmount_smaller_angle);
            transferB = stepAmount_greater_angle - Math.floor(stepAmount_greater_angle);
        } else {
            stepAmount_smaller_angle = smaller_angle/Math.abs(angle_step_size) + transferB;
            stepAmount_greater_angle = greater_angle/Math.abs(angle_step_size) + transferA;
            transferB = stepAmount_smaller_angle - Math.floor(stepAmount_smaller_angle);
            transferA = stepAmount_greater_angle - Math.floor(stepAmount_greater_angle);
        }
        
        stepAmount_smaller_angle = Math.floor(stepAmount_smaller_angle);
        stepAmount_greater_angle = Math.floor(stepAmount_greater_angle);
        */
        stepAmount_smaller_angle = Math.round(smaller_angle/Math.abs(angle_step_size));
        stepAmount_greater_angle = Math.round(greater_angle/Math.abs(angle_step_size));
        //handle if one or two angles are 0
        if(stepAmount_smaller_angle == 0) {
            extra_steps = 0;
        } else {
            extra_steps = stepAmount_greater_angle / stepAmount_smaller_angle;
            //edge case if angles are same and the greater angle gets decreased by 1 step bc of transfer
            if(stepAmount_greater_angle < stepAmount_smaller_angle) {
                extra_steps = 1;
            }
        }
        
        
        
        frac_remaining_step = extra_steps - Math.floor(extra_steps); //decimal 0.x value
        extra_steps = Math.floor(extra_steps); //integer value; determines how more often greater angle has to be turned
        /*##transfer commented out##
        resultingRemainder = (frac_remaining_step * stepAmount_smaller_angle) - Math.floor(frac_remaining_step * stepAmount_smaller_angle); //decimal value of the remaining step for the motor with greater angle
        a_is_smaller ? transferB += resultingRemainder : transferA += resultingRemainder;*/
        remainder = 0; //missing stepsize
        return [a_is_smaller, a_is_negativ, b_is_negativ, stepAmount_smaller_angle, frac_remaining_step, extra_steps, remainder];
    }
    
    //main method: performs drawing
    //has 2 for loops: 1. for turning smaller angle; 2. for turning bigger angle
    async function operateMotors(timeInterval, angleA, angleB, color) {
        [a_is_smaller, a_is_negativ, b_is_negativ, stepAmount_smaller_angle, frac_remaining_step, extra_steps, remainder] = calcParameters(angleA, angleB);
        if (stepAmount_smaller_angle == 0) {
            for(let progress = 0; progress < stepAmount_greater_angle; progress++) {

                //waits on pause
                while (pause) {
                    await sleep(100);
                }

                //exits on restart
                if (!running) {
                    return;
                }

                //turn side with bigger angle
                a_is_smaller ? lengthB = turn_B(lengthB, angle_step_size, b_is_negativ) : lengthA = turn_A(lengthA, angle_step_size, a_is_negativ);
                let [c_x, c_y] = calculateEndPoint(lengthA, lengthB);

                drawForeground(c_x, c_y);
                drawBackground(c_x, c_y);
            }
        }

        sleepTime_per_Iter = timeInterval/stepAmount_smaller_angle; //theoretical estimated time to sleep after each iteration
        //console.log(sleepTime_per_Iter);

        for (let progress = 0; progress < stepAmount_smaller_angle; progress++) { 
            //waits on pause
            while (pause) {
                await sleep(100);
            }

            //exits on restart
            if (!running) {
                return;
            }

            //STARTTIME OF ITERATION
            iter_startTime = performance.now();

            //turn side with smaller angle
            a_is_smaller ? lengthA = turn_A(lengthA, angle_step_size, a_is_negativ) : lengthB = turn_B(lengthB, angle_step_size, b_is_negativ);

            //count the fractional extra steps for the motor with greater turnangle
            remainder += frac_remaining_step;

            //turn side with bigger angle
            for (let i = 0; i < extra_steps; i++) {
                a_is_smaller ? lengthB = turn_B(lengthB, angle_step_size, b_is_negativ) : lengthA = turn_A(lengthA, angle_step_size, a_is_negativ);
                let [c_x, c_y] = calculateEndPoint(lengthA, lengthB);
                drawForeground(c_x, c_y);
                drawBackground(c_x, c_y, color);
                
                // sometimes turn one extra (for decimal)
                if (remainder >= 1) {
                    i--; 
                    remainder--;
                }
            }

            //ENDTIME OF ITERATION
            iter_endTime = performance.now();
            time_per_iter = iter_endTime - iter_startTime;

            //Animation: sometimes wait 1ms
            acc_sleep += sleepTime_per_Iter - time_per_iter;
            if (acc_sleep >= animSpeed * frametime) {
                await sleep(frametime);
                acc_sleep -= animSpeed * frametime;
            }
        }    
    }

    //angle_sequence: a tupel containing sequenc(es); for start/end, the tupel only contains 1 ele
    async function update(angle_sequence, draw_bg="grey") {
        for (let i = 0; i < angle_sequence.length; i++) {
            timeInterval = angle_sequence[i][0];
            angleA = angle_sequence[i][1];
            angleB = angle_sequence[i][2];
            cur_iter.textContent = iter_count++;
            
            await operateMotors(timeInterval, angleA, angleB, draw_bg);

            //await sleep(timeInterval);

            if (!running) {
                return; // Prevent overlapping calls
            }

            if (i % 1000 == 0) { //always sleep sometimes -> browser doesnt crash
                await sleep(1);
            }
        }
    }

    //controls Error Handling
    function handleError(msg) {
        if (stop_on_error_checkbox.checked) {
            cur_iter.textContent += " (crashed)";
            running = false;  // stop animation
        }
        error_logger.textContent = msg;
    }

    //sleeps given amount of time
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    //helper function to parse ANGLES from text from .txt files
    function parse(raw_text) {
        const tupleOfTuples = raw_text
        .split('\n') //split on newline
        .map(line => line.trim()) // Remove extra spaces/newlines
        .filter(line => line.length > 0) // Remove empty lines
        .map(line => line.split(',').map(Number)); //converts strings to Numbers & constructs tripel
        return tupleOfTuples;
    }

    //helper function to pretty print angles tuples
    //prints first and last print_limit lines and length
    function pretty_print(tupleOfTuples) {
        let print_limit = 1;
        amount_angleSeqs = tupleOfTuples.length;
        let pretty_string = "Total: " + tupleOfTuples.length + "<br>";

        if (amount_angleSeqs > print_limit) { //tupel too big -> get only some eles
            let first_eles = tupleOfTuples.slice(0, print_limit);
            let last_eles = tupleOfTuples.slice(-print_limit);
            tupleOfTuples = [...first_eles, ["..."], ...last_eles];
        }
        
        //pretty print it
        tupleOfTuples.forEach((tuple) => {
            pretty_string += tuple.join(", ") + "<br>";
        });

        return pretty_string;
    }
    
    // Function to check/uncheck the button based on checkbox state
    function config_Angles() {
        if (file_checkbox.checked) {
            fileInput.disabled = false; // enable button
            ANGLES = [];
            angle_output.textContent = `No ANGLES. Please upload File`;
            start_button.disabled = true;

        } else if (pre1_checkbox.checked) {
            fileInput.disabled = true; // disable button
            //get ANGLES from hardcode-1
            ANGLES = PRE1_ANGLES;
            to_drawStart = ANGLES.slice(0,1);
            to_begin = ANGLES.slice(1,2);
            ANGLES = ANGLES.slice(2);
            angle_output.innerHTML = `Use ANGLES from preload 1: <br> ${pretty_print(ANGLES)}`;
            start_button.disabled = false;

        } else if (pre2_checkbox.checked) {
            fileInput.disabled = true; // disable button
            //get ANGLES from hardcode-2
            ANGLES = PRE2_ANGLES;
            to_drawStart = ANGLES.slice(0,1);
            to_begin = ANGLES.slice(1,2);
            ANGLES = ANGLES.slice(2);
            angle_output.innerHTML = `Use ANGLES from preload 2: <br> ${pretty_print(ANGLES)}`;
            start_button.disabled = false;
        }
    }
        
    // Function to load file content
    function load_File() {
        let file = fileInput.files[0];
        if (!file) {
            angle_output.textContent = "Please upload a file first";
            return;
        }
        const fr = new FileReader();
        fr.onload = function () {
            ANGLES = parse(fr.result);
            to_drawStart = ANGLES.slice(0,1);
            to_begin = ANGLES.slice(1,2);
            ANGLES = ANGLES.slice(2);
            angle_output.innerHTML = `Use ANGLES from file: <br> ${pretty_print(ANGLES)}`;
            start_button.disabled = false;
        };
        fr.readAsText(file);
    }

    function get_slider_dcoil() {
        dcoil_value.textContent = dcoil_slider.value;
        D_COIL = dcoil_slider.value;
        U_COIL = Math.PI * D_COIL;
    }

    function hide_fg() {
        if (hide_fg_checkbox.checked) {
            fg_ctx.clearRect(0, 0, CANVASWIDTH, CANVASHEIGHT);
        } else {
            //calculate last endpoint
            let [c_x, c_y] = calculateEndPoint(lengthA, lengthB);
            drawForeground(c_x, c_y); 
        }
    }

    function hide_grid() {
        if (hide_grid_checkbox.checked) {
            grid_ctx.clearRect(0, 0, CANVASWIDTH, CANVASHEIGHT);
        } else {
            drawGrid();
        }
    }

    function set_startingPoint() {
        starting_point_x = parseFloat(starting_point_x_entry.value);
        starting_point_y = parseFloat(starting_point_y_entry.value);

        //check for correct number format
        if (isNaN(starting_point_x) || isNaN(starting_point_y)) {
            handleError("Invalid input of coordinates");
        }

        //change starting length
        lengthA = Math.sqrt(Math.pow(starting_point_x - coords_motor_A[0], 2) + Math.pow(starting_point_y - coords_motor_A[1], 2));
        lengthB = Math.sqrt(Math.pow(starting_point_x - coords_motor_B[0], 2) + Math.pow(starting_point_y - coords_motor_B[1], 2));
        let [c_x, c_y] = calculateEndPoint(lengthA, lengthB);
    }

    async function get_slider_speed() {
        acc_sleep = 0; //reset acculumated sleep time
        if (parseFloat(speed_slider.value) > 100) {
            speed_slider.value = 105;
            speed_value.textContent = '\u221E'; // Unicode for infty
            animSpeed = Infinity;
        } else if (parseFloat(speed_slider.value) <= 1) {
            speed_slider.value = 1;
            speed_value.textContent = 1;
            animSpeed = 1;
        } else {
            speed_value.textContent = speed_slider.value;
            animSpeed = speed_slider.value;
        }
        await sleep(100); //wait for GUI to refresh in case of too speedy
    }

    function resizeCanvas() {
        CANVASWIDTH = parseFloat(width_entry.value);
        CANVASHEIGHT = parseFloat(heigth_entry.value);

        //check for correct number format
        if (isNaN(CANVASWIDTH) || isNaN(CANVASHEIGHT)) {
            handleError("Invalid input of size");
        }

        gridCanvas.width = CANVASWIDTH;
        gridCanvas.height = CANVASHEIGHT;
        bgCanvas.width = CANVASWIDTH;
        bgCanvas.height = CANVASHEIGHT;
        fgCanvas.width = CANVASWIDTH;
        fgCanvas.height = CANVASHEIGHT;    

        OFFSET_X = CANVASWIDTH * offset_x_ratio; //for drawing area
        OFFSET_Y = CANVASHEIGHT * offset_y_ratio; //for drawing area
        WIDTH_DRAWINGAREA = CANVASWIDTH * drawingWidth_ratio; 
        HEIGHT_DRAWINGAREA = CANVASHEIGHT * drawingHeight_ratio; 
        coords_motor_A = [0, 0];
        coords_motor_B = [CANVASWIDTH, 0];
    }

    function resizeDrawingArea() {
        WIDTH_DRAWINGAREA = parseFloat(drawwidth_entry.value); 
        HEIGHT_DRAWINGAREA = parseFloat(drawheight_entry.value); 

        //check for correct number format
        if (isNaN(WIDTH_DRAWINGAREA) || isNaN(HEIGHT_DRAWINGAREA)) {
            handleError("Invalid input of size");
        }

        //calc new vars
        const dist_toBot = 40;
        OFFSET_X = (CANVASWIDTH-WIDTH_DRAWINGAREA)/2;
        OFFSET_Y = (CANVASHEIGHT-HEIGHT_DRAWINGAREA)-dist_toBot;
        lengthA = Math.sqrt(Math.pow(OFFSET_X, 2) + Math.pow(OFFSET_Y, 2));
        lengthB = Math.sqrt(Math.pow(CANVASWIDTH-OFFSET_X, 2) + Math.pow(OFFSET_Y, 2));
    }

    function init() {
        //reset vars
        remainder = 0;
        /*##transfer commented out##
        transferA = 0;
        transferB = 0; */
        iter_count = 0;
        pixels = [];
        cur_iter.textContent = "(not started)";
        error_logger.textContent = "No errors so far";

        //clear Canvas
        bg_ctx.clearRect(0, 0, CANVASWIDTH, CANVASHEIGHT);
        fg_ctx.clearRect(0, 0, CANVASWIDTH, CANVASHEIGHT);
        grid_ctx.clearRect(0, 0, CANVASWIDTH, CANVASHEIGHT);

        //call methods
        resizeCanvas(); //resize canvas if wanted
        resizeDrawingArea(); //resize drawingArea if wanted
        set_startingPoint(); //set to topLeft of drawArea + reset lengths

        [c_x, c_y] = calculateEndPoint(lengthA, lengthB);
        drawForeground(c_x, c_y);
        hide_grid();
    }

    async function start() {
        reset();
        start_button.disabled = true;
        running = true;
        pause = false;
    
        let startEnd_color = "rgba(128, 0, 128, 0)";
        let draw_color = "rgba(120 120, 120, 1)";
        startTime = Date.now();
        await update(to_drawStart, startEnd_color);
        let pos_drawStart = [c_x, c_y];
        await update(ANGLES, );
        let pos_drawEnd = [c_x, c_y];
        await update(to_begin, startEnd_color);
        let pos_end = [c_x, c_y];
        endTime = Date.now();
        let error = Math.sqrt((Math.pow(pos_end[0]-OFFSET_X,2)) + (Math.pow(pos_end[1]-OFFSET_Y,2)));
        
        cur_iter.textContent += " (finished)";

        console.log(`
            SUMMARY:
            Total needed time: ${endTime - startTime}ms
            Position of DrawStart: x=${pos_drawStart[0].toFixed(2)}; y=${pos_drawStart[1].toFixed(2)}
            Position of DrawEnd: x=${pos_drawEnd[0].toFixed(2)}; y=${pos_drawEnd[1].toFixed(2)}
            Position of Start: x=${OFFSET_X.toFixed(2)}; y=${OFFSET_Y.toFixed(2)}
            Position of End: x=${pos_end[0].toFixed(2)}; y=${pos_end[1].toFixed(2)}
            Error = ${error.toFixed(2)}mm
        `);

        mod_counter = 0;
        start_button.disabled = false;
    }

    function reset() {
        running = false;
        start_button.disabled = false;
        dcoil_slider.disabled = false;
        init();
    }
    
    function resume() {
        pause = !pause;
    }

    // event listeners
    file_checkbox.addEventListener("change", config_Angles);
    pre1_checkbox.addEventListener("change", config_Angles);
    pre2_checkbox.addEventListener("change", config_Angles);
    fileInput.addEventListener("change", load_File);
    hide_fg_checkbox.addEventListener("change", hide_fg);
    hide_grid_checkbox.addEventListener("change", hide_grid);
    dcoil_slider.addEventListener('input', get_slider_dcoil);
    speed_slider.addEventListener('input', get_slider_speed);
    
    width_entry.addEventListener('input', function() {
        resizeCanvas();
        //override other corresponding values
        drawwidth_entry.value = WIDTH_DRAWINGAREA;
        drawheight_entry.value = HEIGHT_DRAWINGAREA;
        starting_point_x_entry.value = OFFSET_X;
        starting_point_y_entry.value = OFFSET_Y;
        init();
    });

    heigth_entry.addEventListener('input', function() {
        resizeCanvas();
        //override other corresponding values
        drawwidth_entry.value = WIDTH_DRAWINGAREA;
        drawheight_entry.value = HEIGHT_DRAWINGAREA;
        starting_point_x_entry.value = OFFSET_X;
        starting_point_y_entry.value = OFFSET_Y;
        init();
    });

    drawwidth_entry.addEventListener('input', function() {
        resizeDrawingArea();
        //override other corresponding values
        starting_point_x_entry.value = OFFSET_X;
        starting_point_y_entry.value = OFFSET_Y;
        init();
    });

    drawheight_entry.addEventListener('input', function() {
        resizeDrawingArea();
        //override other corresponding values
        starting_point_x_entry.value = OFFSET_X;
        starting_point_y_entry.value = OFFSET_Y;
        init();
    });

    starting_point_x_entry.addEventListener('input', function() {
        init();
    });

    starting_point_y_entry.addEventListener('input', function() {
        init();
    });

    // define functions for keys on keyboard
    document.addEventListener("keydown", (event) => {
        switch (event.key) {
            case " ":
                //console.log("leer gedrückt, runnung: ", running);
                //if (running) {
                    pause_button.click();
                //} else {
                    //start_button.click();
                //}
                event.preventDefault(); // Verhindert Scrollen der Seite
                
                break;
            case 'd':
                speed_slider.value = parseFloat(speed_slider.value) + parseFloat(speed_slider.step);
                get_slider_speed();
                break;
            case 'a':
                speed_slider.value = parseFloat(speed_slider.value) - parseFloat(speed_slider.step);
                get_slider_speed();
                break;
            case 'w':
                speed_slider.value = speed_slider.max;
                get_slider_speed();
                break;
            case 's':
                speed_slider.value = speed_slider.min;
                get_slider_speed();
                break;
            case 'Escape':
                reset();
                break;
        }
    });
    
    //initial things (after DOM has loaded)
    document.addEventListener('DOMContentLoaded', () => {
        file_checkbox.checked = true;
        dcoil_slider.value = 16;
        speed_slider.value = 50;
        width_entry.value = 1910;
        heigth_entry.value = 965;
        drawwidth_entry.value = 1280;
        drawheight_entry.value = 720;
        starting_point_x_entry.value = 315;
        starting_point_y_entry.value = 205;

        config_Angles();
        get_slider_dcoil();
        get_slider_speed();

        init();
    });

    </script>
</body>
</html>