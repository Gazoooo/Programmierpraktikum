<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Simulation - Arduino</title>
    <style>
        body {
            font-size: 20px;
        }

        input[type="file"] {
            font-size: 20px;
            padding: 10px; 
        }

        input[type="checkbox"],
        input[type="radio"] {
            width: 25px;
            height: 25px;
        }
        
        button {
            display: flex;
            font-size: 20px;
            flex-direction: column;
            padding: 10px;
            border-radius: 5px;
        }

        #canvas-container {
            position: relative;
            float: left;
            width: 1910px;
            height: 965px;
            margin-bottom: 20px;
            margin-right: 20px;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        .not_working, .not_working * {
            color: red !important;  
            cursor: not-allowed;  
            opacity: 0.3; 
        }

        #error_logger {
            color: red;
        }
    </style>
</head>

<body>
    <div id="canvas-container">
        <canvas id="gridCanvas" width="1910" height="965" style="border:1px solid #000000;"></canvas>
        <canvas id="bgCanvas" width="1910" height="965" style="border:1px solid #000000;"></canvas>
        <canvas id="fgCanvas" width="1910" height="965" style="border:1px solid #000000;"></canvas>
    </div>

    <div id="simulation-container">
        <h2> Simulation </h2>
        <button type="button" id="start_but" onclick="start()">Start</button>
        <button type="button" id="pause_but" onclick="resume()">Pause/Resume</button>
        <button type="button" id="reset_but" onclick="reset()">Reset</button>
        <input type="checkbox" id="hide_fg_checkbox">Versteck Seile & Stift <br>
        <input type="checkbox" id="hide_grid_checkbox" checked>Versteck Koordinatensystem <br>
        <input type="checkbox" id="stop_on_error_checkbox">Stop on errors <br> 
        
        <input type="range" id="speed_slider" min="0" max="105" step="5"> Adjust Speed: <span id="speed_value"> </span>x <br>
    </div>

    <hr>

    <div id="variablen-container"> 
        <h2> Variablen </h2>
        <input type="range" id="dcoil_slider" min="8" max="32" step="8"> Diameter Coil:  <span id="dcoil_value">  </span> <br>

        <input type="number" id="canvaswidth"> Canvaswidth: <br>
        <input type="number" id="canvasheight"> Canvasheight: <br>
        <input type="number" id="drawwidth"> Drawwidth: <br>
        <input type="number" id="drawheight"> Drawheight: <br>

        <input type="number" id="starting_point_x"> Start x: <br>
        <input type="number" id="starting_point_y"> Start y: <br>
    </div>

    <hr>
       
    <div>
        <h2>Angles-Config</h2>
        <div id="config-container">
            <input type="radio" name="config-angles" id="pre-1"> Use pre-build angles 1
            <input type="radio" name="config-angles" id="pre-2"> Use pre-build angles 2
            <input type="radio" name="config-angles" id="fileContent"> Use fileContent angles
        </div>

        <div> 
            <input type="file" id="fileInput" />
            <p id="angle_info"></p>
        </div>

    </div>

    <hr>

    <div>
        <h2>Logs</h2>
        <p id="update_logger">Processing angleNum: <span id="cur_iter">0</span></p>
        <p id="error_logger"></p>
    </div>

    <script>

    // html elements
    const gridCanvas = document.getElementById("gridCanvas");
    const bgCanvas = document.getElementById("bgCanvas");
    const fgCanvas = document.getElementById("fgCanvas");
    const width_entry = document.getElementById("canvaswidth");
    const heigth_entry = document.getElementById("canvasheight");
    const drawwidth_entry = document.getElementById("drawwidth");
    const drawheight_entry = document.getElementById("drawheight");
    const hide_fg_checkbox = document.getElementById("hide_fg_checkbox");
    const hide_grid_checkbox = document.getElementById("hide_grid_checkbox");
    const stop_on_error_checkbox = document.getElementById("stop_on_error_checkbox");
    const angle_output = document.getElementById("angle_info");
    const fileInput = document.getElementById("fileInput");
    const pre1_checkbox = document.getElementById('pre-1');
    const pre2_checkbox = document.getElementById('pre-2');
    const file_checkbox = document.getElementById('fileContent');
    const start_button = document.getElementById('start_but');
    const pause_button = document.getElementById('pause_but');
    const reset_button = document.getElementById('reset_but');
    const dcoil_slider = document.getElementById("dcoil_slider");
    const starting_point_x_entry = document.getElementById('starting_point_x');
    const starting_point_y_entry = document.getElementById('starting_point_y');
    const speed_slider = document.getElementById('speed_slider');
    let update_logger = document.getElementById('update_logger');
    let error_logger = document.getElementById('error_logger');
    let cur_iter = document.getElementById("cur_iter");
    let dcoil_value = document.getElementById("dcoil_value");

    // hardware
    const DELAY = 1 //ms (would be 0.6, but <1 not sleepable in JS)
    let D_COIL, U_COIL; ////measurements of coil; standard is d=16mm
    let angle_step_size = 1.8 / 16; //min. stepsize the arduino can handle

    //coordinates
    const GRID_SPACING = 100; //mm
    const ORIGIN = [0,0];
    const offset_x_ratio = 63/382; //ratio original Offset (315) Canvaswidth (1910)
    const offset_y_ratio = 41/193; //ratio original Offset (205) Canvasheight (965)
    const drawingWidth_ratio = 128/191;
    const drawingHeight_ratio = 144/193;
    let CANVASWIDTH, CANVASHEIGHT; 
    let WIDTH_DRAWINGAREA, HEIGHT_DRAWINGAREA;
    let OFFSET_X, OFFSET_Y; //upper left start from drawing area
    let coords_motor_A = [0,0];
    let coords_motor_B = [CANVASWIDTH, 0];
    let starting_point_x, starting_point_y;

    //list of tripels (time [ms], leftMotor [degrees], rightMotor [degrees])
    const PRE1_ANGLES = [
        [0,0,0],
        [0,0,0],
        [1000,8613,3376],
        [1000,-8613,-3376],
        [1000,17651,-17651],
        [1000,3376,8613],
        [1000,-12414,12414]
    ]; 

    const PRE2_ANGLES = [
        [1000, 4876, -4461],
        [1000, -4876, 4461],
        [1000, 5730, 2865],
        [1000, -2865, 2865],
        [1000, -2865, -5730]
    ]; 

    // derived vars
    
    let lengthA, lengthB;

    // simulation
    const grid_ctx = gridCanvas.getContext("2d");
    const bg_ctx = bgCanvas.getContext("2d");
    const fg_ctx = fgCanvas.getContext("2d");
    let pause = false;
    let running = false; // Flag to check if update is running
    let pixels = [];
    let c_x, c_y; //coords of pen
    let iter_count = 0; //counter for cur_iter html element
    let amount_angleSeqs = 1; //amount of angle seqs loaded
    let ANGLES; //Array where the angleSeqs are stored
    let to_drawStart; //Angle from top left to start
    let to_begin; //Angle from endpoint to top left

    // run continuous
    let extra_steps;
    let a_is_smaller = true;
    let remainder = 0;
    let angleA;
    let angleB;
    let abs_angleA;
    let abs_angleB; 
    let a_is_negativ;
    let b_is_negativ;
    let smaller_angle;
    let greater_angle;
    let stepAmount_smaller_angle;
    let stepAmount_greater_angle;
    /*##transfer commented out##
    let transferA = 0;
    let transferB = 0;*/
    let resultingRemainder = 0;
    let a_was_negativ = false;
    let b_was_negativ = false;
    let frac_remaining_step = 0;

    // animation
    const framerate = 60;
    const frametime = 1/60 * 1000;
    let timeInterval; //1. ele of each tupel
    let animSpeed = 1; //value higher (-> less sleep calls) -> animation faster
    let time_per_iter = 0; //Time needed for 1 Iteration
    let iter_startTime;
    let iter_endTime;
    let sleepTime_per_Iter; //calculated time for sleep each iter
    let startTime; //starttime of each run
    let endTime; //endtime of each run
    let acc_sleep = 0; //acculumated sleepTime

    /**
    * Calculates the endpoint from two lines using the Pythagorean theorem.
    *
    * @param {number} s1 - Length from motor A to the endpoint.
    * @param {number} s2 - Length from motor B to the endpoint.
    * @returns {[number, number]} The [x, y] coordinates of the calculated endpoint.
    *
    * @throws Will call handleError with a warning if the point is outside the drawing area.
    * @throws Will call handleError with an error if the point is completely out of canvas bounds.
    */
    function calculateEndPoint(s1, s2) {
        c_x = (Math.pow(s1, 2) - Math.pow(s2, 2) + Math.pow(coords_motor_B[0], 2)) / (2 * coords_motor_B[0]);
        c_y = Math.sqrt(Math.pow(s2, 2) - Math.pow((coords_motor_B[0] -c_x), 2))

        if (c_x > OFFSET_X+WIDTH_DRAWINGAREA || c_x < OFFSET_X || c_y > OFFSET_Y+HEIGHT_DRAWINGAREA || c_y < OFFSET_Y) {
            handleError("Warning: Out of Drawing Area");
        }

        if (c_x > CANVASWIDTH || c_x < 0 || c_y > CANVASHEIGHT || c_y < 0) {
            handleError("Error: Out of Bounds");
        }

        return [c_x, c_y];
    }
    
    /**
    * Calculates the length of a line based on the rotation angle of the motor.
    *
    * @param {number} angle - The rotation angle of the motor in degrees.
    * @param {number} cur_length - The current length of the line.
    * @returns {number} The new length of the line after applying the rotation.
    */
    function calc_length(angle, cur_length) {
        let extraLength = angle / 360 * U_COIL;
        return cur_length + extraLength;
    }

    /** Draws the grid and axes on the canvas.
    * The grid is drawn with a specified spacing, and the axes are labeled with coordinates.
    * The drawing area is highlighted in green.
    */
    function drawGrid() {
        //draw Axes
        grid_ctx.strokeStyle = "black";
        grid_ctx.lineWidth = 1;
        // X-Axes
        grid_ctx.beginPath();
        grid_ctx.moveTo(0, 0);
        grid_ctx.lineTo(CANVASWIDTH, 0);
        grid_ctx.stroke();
        // Y-Axes
        grid_ctx.beginPath();
        grid_ctx.moveTo(0, 0);
        grid_ctx.lineTo(0, CANVASHEIGHT);
        grid_ctx.stroke();
        

        //draw helper grid lines
        grid_ctx.lineWidth = 0.5;
        //vertical
        for (let x = 0; x <= CANVASWIDTH; x += GRID_SPACING*0.1) {
            grid_ctx.strokeStyle = "#ccc";
            grid_ctx.beginPath();
            grid_ctx.moveTo(x, 0);
            if (x % GRID_SPACING == 0) { //draw some lines 50% darker
                grid_ctx.strokeStyle = "#666666";
            }
            grid_ctx.lineTo(x, CANVASHEIGHT);
            grid_ctx.stroke();
        }
        //horizontal
        for (let y = 0; y <= CANVASHEIGHT; y += GRID_SPACING*0.1) {
            grid_ctx.strokeStyle = "#ccc";
            grid_ctx.beginPath();
            grid_ctx.moveTo(0, y);
            if (y % GRID_SPACING == 0) { //draw some lines 50% darker
                grid_ctx.strokeStyle = "#666666";
            }
            grid_ctx.lineTo(CANVASWIDTH, y);
            grid_ctx.stroke();
        }
        
        //draw labels
        grid_ctx.fillStyle = "black";
        grid_ctx.font = "12px Arial";
        for (let x = 0; x <= CANVASWIDTH; x += GRID_SPACING) {
            grid_ctx.fillText(x, x, 10);
        }
        for (let y = 0; y <= CANVASHEIGHT; y += GRID_SPACING) {
            grid_ctx.fillText(y, 0, y);
        }

        //draw drawing area
        grid_ctx.lineWidth = 2;
        grid_ctx.strokeStyle = "green";
        grid_ctx.beginPath();
        grid_ctx.strokeRect(OFFSET_X, OFFSET_Y, WIDTH_DRAWINGAREA, HEIGHT_DRAWINGAREA);
    }

    /** Draws the foreground elements on the canvas.
    * This includes the lines from the motors to the pen and the pen itself.
    * The lines are drawn in blue, and the pen is drawn in red.
    * The function takes the current coordinates of the pen as parameters.
    * @param {number} c_x - The x-coordinate of the pen.
    * @param {number} c_y - The y-coordinate of the pen.
    */
    function drawForeground(c_x, c_y) {
        fg_ctx.clearRect(0, 0, CANVASWIDTH, CANVASHEIGHT);
        if(hide_fg_checkbox.checked) {
            return;
        }
        // lines
        fg_ctx.beginPath();
        fg_ctx.strokeStyle = 'blue'; 
        fg_ctx.lineWidth = 2;

        // 1. line (start on upper left corner)
        fg_ctx.moveTo(coords_motor_A[0], coords_motor_A[1]);       
        fg_ctx.lineTo(c_x, c_y);

        // 2. line (start on upper right corner)
        fg_ctx.moveTo(coords_motor_B[0], coords_motor_B[1]); 
        fg_ctx.lineTo(c_x, c_y);        
        fg_ctx.stroke();

        // pen
        fg_ctx.beginPath();
        fg_ctx.arc(c_x, c_y, 5, 0, 2 * Math.PI);
        fg_ctx.fillStyle = 'red';
        fg_ctx.fill();
        fg_ctx.stroke();
    }

    /** Draws the background elements on the canvas.
    * This includes the lines from the motors to the pen and the pen itself.
    * The lines are drawn in blue, and the pen is drawn in red.
    * The function takes the current coordinates of the pen as parameters.
    * @param {number} c_x - The x-coordinate of the pen.
    * @param {number} c_y - The y-coordinate of the pen.
    * @param {string} color - The color to fill the background with.
    */
    function drawBackground(c_x, c_y, color='grey') {
        //pixels.push({c_x, c_y});
        bg_ctx.fillStyle = color;
        bg_ctx.fillRect(c_x, c_y, 1, 1);
    }

    /**
    * Simulates turning motor A and calculates the resulting line length.
    *
    * If the angle is negative, it shortens the line (rewinding the motor).
    * Both motors are assumed to turn in the same direction.
    *
    * @param {number} length - The current length of the line.
    * @param {number} angle_step_size - The amount of rotation to apply (in degrees).
    * @param {boolean} a_is_negativ - Whether the motor should turn in the negative direction.
    * @returns {number} The new length of the line after turning the motor.
    */
    function turn_A(length, angle_step_size, a_is_negativ) {
        angle_step_size = a_is_negativ ? (-Math.abs(angle_step_size)) : Math.abs(angle_step_size); 
        return calc_length(angle_step_size, length);
    }
    
    /**
    * Simulates turning motor B and calculates the resulting line length.
    *
    * If the angle is negative, it shortens the line (rewinding the motor).
    * Both motors are assumed to turn in the same direction.
    *
    * @param {number} length - The current length of the line.
    * @param {number} angle_step_size - The amount of rotation to apply (in degrees).
    * @param {boolean} b_is_negativ - Whether the motor should turn in the negative direction.
    * @returns {number} The new length of the line after turning the motor.
    */
    function turn_B(length, angle_step_size, b_is_negativ) {
        angle_step_size = b_is_negativ ? (-Math.abs(angle_step_size)) : Math.abs(angle_step_size);
        return calc_length(angle_step_size, length);
    }

    /**
    * Helper function for `operateMotors()` to calculate control parameters
    * based on the current angles of motor A and B.
    *
    * Calculates which angle is smaller, whether the angles are negative or positive,
    * and how many steps each motor should take. Also prepares values for error correction.
    *
    * @param {number} angleA - The rotation angle of motor A in degrees.
    * @param {number} angleB - The rotation angle of motor B in degrees.
    * @returns {[boolean, boolean, boolean, number, number, number, number]} 
    * Returns a tuple with:
    *  - `a_is_smaller`: `true` if angleA is smaller or equal to angleB,
    *  - `a_is_negativ`: `true` if angleA is negative,
    *  - `b_is_negativ`: `true` if angleB is negative,
    *  - `stepAmount_smaller_angle`: number of steps for the smaller angle,
    *  - `frac_remaining_step`: fractional part of the extra steps,
    *  - `extra_steps`: how often the larger motor must step compared to the smaller one,
    *  - `remainder`: unused step portion, currently `0`.
    */
    function calcParameters(angleA, angleB) {
        //determines
        //smaller and greater angle
        //if angles are negativ or positiv
        abs_angleA = Math.abs(angleA);
        abs_angleB = Math.abs(angleB);
        a_is_smaller = abs_angleA <= abs_angleB; 
        a_was_negativ = a_is_negativ;
        b_was_negativ = b_is_negativ;
        a_is_negativ = angleA < 0;
        b_is_negativ = angleB < 0;
        smaller_angle = Math.min(abs_angleA, abs_angleB);
        greater_angle = Math.max(abs_angleA, abs_angleB);
        
        
        /* ############ Transfer for presumably more accurate drawing with less error overall ############
        ## commented out to approximate Arduino hardware solution better ##  
        //if there is a sign switch the transfer of the last angle pair has to be negativ 
        if(a_was_negativ != a_is_negativ) {
            transferA = -transferA;
        }
        if(b_was_negativ != b_is_negativ) {
            transferB = -transferB;
        }
        
        //add remaining fractual step of former iteration   
        //calculate stepAmount for each motor and add the fractual step to the transfer
        if(a_is_smaller) {
            stepAmount_smaller_angle = smaller_angle/Math.abs(angle_step_size) + transferA;
            stepAmount_greater_angle = greater_angle/Math.abs(angle_step_size) + transferB;
            transferA = stepAmount_smaller_angle - Math.floor(stepAmount_smaller_angle);
            transferB = stepAmount_greater_angle - Math.floor(stepAmount_greater_angle);
        } else {
            stepAmount_smaller_angle = smaller_angle/Math.abs(angle_step_size) + transferB;
            stepAmount_greater_angle = greater_angle/Math.abs(angle_step_size) + transferA;
            transferB = stepAmount_smaller_angle - Math.floor(stepAmount_smaller_angle);
            transferA = stepAmount_greater_angle - Math.floor(stepAmount_greater_angle);
        }
        
        stepAmount_smaller_angle = Math.floor(stepAmount_smaller_angle);
        stepAmount_greater_angle = Math.floor(stepAmount_greater_angle);
        */
        stepAmount_smaller_angle = Math.round(smaller_angle/Math.abs(angle_step_size));
        stepAmount_greater_angle = Math.round(greater_angle/Math.abs(angle_step_size));
        //handle if one or two angles are 0
        if(stepAmount_smaller_angle == 0) {
            extra_steps = 0;
        } else {
            extra_steps = stepAmount_greater_angle / stepAmount_smaller_angle;
            //edge case if angles are same and the greater angle gets decreased by 1 step bc of transfer
            if(stepAmount_greater_angle < stepAmount_smaller_angle) {
                extra_steps = 1;
            }
        }
        
        
        
        frac_remaining_step = extra_steps - Math.floor(extra_steps); //decimal 0.x value
        extra_steps = Math.floor(extra_steps); //integer value; determines how more often greater angle has to be turned
        /*##transfer commented out##
        resultingRemainder = (frac_remaining_step * stepAmount_smaller_angle) - Math.floor(frac_remaining_step * stepAmount_smaller_angle); //decimal value of the remaining step for the motor with greater angle
        a_is_smaller ? transferB += resultingRemainder : transferA += resultingRemainder;*/
        remainder = 0; //missing stepsize
        return [a_is_smaller, a_is_negativ, b_is_negativ, stepAmount_smaller_angle, frac_remaining_step, extra_steps, remainder];
    }
    
    /**
    * Main method that performs the drawing by controlling the motors.
    * 
    * This function operates two motors, one for the smaller angle and the other for the larger angle.
    * It has two main loops:
    * 1. For turning the motor with the smaller angle.
    * 2. For turning the motor with the larger angle.
    * 
    * The function calculates the movement step size based on the angles, controls the motors in steps,
    * and manages pause, restart, and timing issues to ensure smooth animation.
    *
    * @param {number} timeInterval - The total time allocated for one complete drawing cycle.
    * @param {number} angleA - The rotation angle of motor A in degrees.
    * @param {number} angleB - The rotation angle of motor B in degrees.
    * @param {string} color - The color to be used for drawing the background of the canvas.
    * @returns {Promise<void>} Returns a promise that resolves when the operation is complete.
    */
    async function operateMotors(timeInterval, angleA, angleB, color) {
        [a_is_smaller, a_is_negativ, b_is_negativ, stepAmount_smaller_angle, frac_remaining_step, extra_steps, remainder] = calcParameters(angleA, angleB);
        if (stepAmount_smaller_angle == 0) {
            for(let progress = 0; progress < stepAmount_greater_angle; progress++) {

                //waits on pause
                while (pause) {
                    await sleep(100);
                }

                //exits on restart
                if (!running) {
                    return;
                }

                //turn side with bigger angle
                a_is_smaller ? lengthB = turn_B(lengthB, angle_step_size, b_is_negativ) : lengthA = turn_A(lengthA, angle_step_size, a_is_negativ);
                let [c_x, c_y] = calculateEndPoint(lengthA, lengthB);

                drawForeground(c_x, c_y);
                drawBackground(c_x, c_y);
            }
        }

        sleepTime_per_Iter = timeInterval/stepAmount_smaller_angle; //theoretical estimated time to sleep after each iteration
        //console.log(sleepTime_per_Iter);

        for (let progress = 0; progress < stepAmount_smaller_angle; progress++) { 
            //waits on pause
            while (pause) {
                await sleep(100);
            }

            //exits on restart
            if (!running) {
                return;
            }

            //STARTTIME OF ITERATION
            iter_startTime = performance.now();

            //turn side with smaller angle
            a_is_smaller ? lengthA = turn_A(lengthA, angle_step_size, a_is_negativ) : lengthB = turn_B(lengthB, angle_step_size, b_is_negativ);

            //count the fractional extra steps for the motor with greater turnangle
            remainder += frac_remaining_step;

            //turn side with bigger angle
            for (let i = 0; i < extra_steps; i++) {
                a_is_smaller ? lengthB = turn_B(lengthB, angle_step_size, b_is_negativ) : lengthA = turn_A(lengthA, angle_step_size, a_is_negativ);
                let [c_x, c_y] = calculateEndPoint(lengthA, lengthB);
                drawForeground(c_x, c_y);
                drawBackground(c_x, c_y, color);
                
                // sometimes turn one extra (for decimal)
                if (remainder >= 1) {
                    i--; 
                    remainder--;
                }
            }

            //ENDTIME OF ITERATION
            iter_endTime = performance.now();
            time_per_iter = iter_endTime - iter_startTime;

            //Animation: sometimes wait 1ms
            acc_sleep += sleepTime_per_Iter - time_per_iter;
            if (acc_sleep >= animSpeed * frametime) {
                await sleep(frametime);
                acc_sleep -= animSpeed * frametime;
            }
        }    
    }

    /**
    * Updates the motor operation based on the provided angle sequence.
    * 
    * This function takes a sequence of angles and corresponding time intervals, and operates the motors accordingly.
    * It updates the motor drawing iteratively and ensures smooth animation by controlling sleep intervals between operations.
    * It also prevents overlapping calls and handles browser performance by adding occasional pauses.
    *
    * @param {Array<Array<number>>} angle_sequence - A sequence of angle data, where each entry contains a tuple with:
    *   - `timeInterval` (number): The time allocated for each motor movement.
    *   - `angleA` (number): The rotation angle for motor A in degrees.
    *   - `angleB` (number): The rotation angle for motor B in degrees.
    * @param {string} [draw_bg="grey"] - The background color for drawing. Defaults to "grey".
    * @returns {Promise<void>} Returns a promise that resolves when the update is complete or stopped.
    */
    async function update(angle_sequence, draw_bg="grey") {
        for (let i = 0; i < angle_sequence.length; i++) {
            timeInterval = angle_sequence[i][0];
            angleA = angle_sequence[i][1];
            angleB = angle_sequence[i][2];
            cur_iter.textContent = iter_count++;
            
            await operateMotors(timeInterval, angleA, angleB, draw_bg);

            //await sleep(timeInterval);

            if (!running) {
                return; // Prevent overlapping calls
            }

            if (i % 1000 == 0) { //always sleep sometimes -> browser doesnt crash
                await sleep(1);
            }
        }
    }

    /**
    * Handles error messages and controls whether the animation stops on errors.
    * 
    * This function updates the error message display and checks if the "stop on error" checkbox is selected.
    * If enabled, it stops the animation and marks the current iteration as "crashed".
    * The error message is logged to the `error_logger` element.
    *
    * @param {string} msg - The error message to be displayed and logged.
    * @returns {void} 
    */
    function handleError(msg) {
        if (stop_on_error_checkbox.checked) {
            cur_iter.textContent += " (crashed)";
            running = false;  // stop animation
        }
        error_logger.textContent = msg;
    }

    /**
    * Pauses execution for a specified amount of time.
    * 
    * This function returns a Promise that resolves after the given number of milliseconds, allowing you to pause
    * the execution of asynchronous code without blocking the thread.
    *
    * @param {number} ms - The number of milliseconds to sleep.
    * @returns {Promise<void>} A Promise that resolves after the specified delay.
    */
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    /**
    * Parses angle data from raw text input (typically from a .txt file).
    * 
    * This helper function processes the raw text, splitting it by newlines and commas, trimming unnecessary spaces,
    * and converting the string values to numbers. It returns an array of tuples, where each tuple represents a set
    * of angles.
    *
    * @param {string} raw_text - The raw text data to be parsed. The text should contain lines with comma-separated values.
    * @returns {Array<Array<number>>} An array of arrays (tuples), where each inner array contains numbers representing angles.
    */
    function parse(raw_text) {
        const tupleOfTuples = raw_text
        .split('\n') //split on newline
        .map(line => line.trim()) // Remove extra spaces/newlines
        .filter(line => line.length > 0) // Remove empty lines
        .map(line => line.split(',').map(Number)); //converts strings to Numbers & constructs tripel
        return tupleOfTuples;
    }

    /**
    * Pretty prints a limited number of angle tuples, showing the total count and a subset of the tuples.
    * 
    * This helper function generates a human-readable string representation of a sequence of angle tuples. 
    * If the number of tuples exceeds a set limit, only the first and last tuples are shown, with a "..." 
    * in between to indicate omitted tuples. The total number of tuples is also displayed.
    *
    * @param {Array<Array<number>>} tupleOfTuples - An array of tuples, where each tuple contains numbers representing angles.
    * @returns {string} A formatted string displaying the total count and the selected angle tuples.
    */
    function pretty_print(tupleOfTuples) {
        let print_limit = 1;
        amount_angleSeqs = tupleOfTuples.length;
        let pretty_string = "Total: " + tupleOfTuples.length + "<br>";

        if (amount_angleSeqs > print_limit) { //tupel too big -> get only some eles
            let first_eles = tupleOfTuples.slice(0, print_limit);
            let last_eles = tupleOfTuples.slice(-print_limit);
            tupleOfTuples = [...first_eles, ["..."], ...last_eles];
        }
        
        //pretty print it
        tupleOfTuples.forEach((tuple) => {
            pretty_string += tuple.join(", ") + "<br>";
        });

        return pretty_string;
    }
    
    /**
    * Configures the angle data source based on the selected checkbox state.
    * 
    * This function checks the state of the checkboxes and enables/disables the file input button accordingly.
    * Depending on which checkbox is selected (file upload, preload 1, or preload 2), it updates the global 
    * `ANGLES` array with the appropriate data source and displays a message with the angle information.
    * The start button is also enabled or disabled based on the configuration.
    * 
    * - If the "file_checkbox" is checked, the file input is enabled, and `ANGLES` is cleared.
    * - If "pre1_checkbox" is checked, `ANGLES` is populated with predefined angles from "PRE1_ANGLES".
    * - If "pre2_checkbox" is checked, `ANGLES` is populated with predefined angles from "PRE2_ANGLES".
    * 
    * @returns {void} This function does not return any value.
    */
    function config_Angles() {
        if (file_checkbox.checked) {
            fileInput.disabled = false; // enable button
            ANGLES = [];
            angle_output.textContent = `No ANGLES. Please upload File`;
            start_button.disabled = true;

        } else if (pre1_checkbox.checked) {
            fileInput.disabled = true; // disable button
            //get ANGLES from hardcode-1
            ANGLES = PRE1_ANGLES;
            to_drawStart = ANGLES.slice(0,1);
            to_begin = ANGLES.slice(1,2);
            ANGLES = ANGLES.slice(2);
            angle_output.innerHTML = `Use ANGLES from preload 1: <br> ${pretty_print(ANGLES)}`;
            start_button.disabled = false;

        } else if (pre2_checkbox.checked) {
            fileInput.disabled = true; // disable button
            //get ANGLES from hardcode-2
            ANGLES = PRE2_ANGLES;
            to_drawStart = ANGLES.slice(0,1);
            to_begin = ANGLES.slice(1,2);
            ANGLES = ANGLES.slice(2);
            angle_output.innerHTML = `Use ANGLES from preload 2: <br> ${pretty_print(ANGLES)}`;
            start_button.disabled = false;
        }
    }
        
    /**
    * Loads the content of the uploaded file and parses the angle data.
    * 
    * This function is triggered when a file is selected for upload. It reads the file using a `FileReader`, 
    * and if a valid file is present, it parses the content using the `parse` function. The parsed angle 
    * data is then stored in the global `ANGLES` variable. Additionally, the first two elements are separated 
    * into `to_drawStart` and `to_begin`, and the remaining angles are stored in `ANGLES`.
    * It then updates the display with the parsed angle data and enables the start button.
    * 
    * If no file is uploaded, a message is shown asking the user to upload a file first.
    * 
    * @returns {void} This function does not return any value.
    */
    function load_File() {
        let file = fileInput.files[0];
        if (!file) {
            angle_output.textContent = "Please upload a file first";
            return;
        }
        const fr = new FileReader();
        fr.onload = function () {
            ANGLES = parse(fr.result);
            to_drawStart = ANGLES.slice(0,1);
            to_begin = ANGLES.slice(1,2);
            ANGLES = ANGLES.slice(2);
            angle_output.innerHTML = `Use ANGLES from file: <br> ${pretty_print(ANGLES)}`;
            start_button.disabled = false;
        };
        fr.readAsText(file);
    }

    /**
    * Updates the coil diameter value based on the slider input and recalculates the coil circumference.
    * 
    * This function is triggered whenever the slider for the coil diameter (`dcoil_slider`) is changed. 
    * It updates the text content of `dcoil_value` to display the current value of the slider and stores 
    * that value in the global variable `D_COIL`. It then calculates the coil circumference (`U_COIL`) 
    * using the formula `U_COIL = Math.PI * D_COIL`.
    * 
    * @returns {void} This function does not return any value.
    */
    function get_slider_dcoil() {
        dcoil_value.textContent = dcoil_slider.value;
        D_COIL = dcoil_slider.value;
        U_COIL = Math.PI * D_COIL;
    }

    /**
    * Clears or redraws the foreground canvas based on the checkbox state.
    * 
    * If the checkbox is checked, the canvas is cleared. If unchecked, the last endpoint
    * is calculated and the foreground is redrawn.
    * 
    * @returns {void}
    */
    function hide_fg() {
        if (hide_fg_checkbox.checked) {
            fg_ctx.clearRect(0, 0, CANVASWIDTH, CANVASHEIGHT);
        } else {
            //calculate last endpoint
            let [c_x, c_y] = calculateEndPoint(lengthA, lengthB);
            drawForeground(c_x, c_y); 
        }
    }

    /**
    * Clears or redraws the grid based on the checkbox state.
    * 
    * If the checkbox is checked, the grid is cleared. If unchecked, the grid is redrawn.
    * 
    * @returns {void}
    */
    function hide_grid() {
        if (hide_grid_checkbox.checked) {
            grid_ctx.clearRect(0, 0, CANVASWIDTH, CANVASHEIGHT);
        } else {
            drawGrid();
        }
    }

    /**
    * Sets the starting point and calculates the new lengths for the motors.
    * 
    * Retrieves coordinates from input fields, validates the input, and updates motor lengths.
    * 
    * @returns {void}
    */
    function set_startingPoint() {
        starting_point_x = parseFloat(starting_point_x_entry.value);
        starting_point_y = parseFloat(starting_point_y_entry.value);

        //check for correct number format
        if (isNaN(starting_point_x) || isNaN(starting_point_y)) {
            handleError("Invalid input of coordinates");
        }

        //change starting length
        lengthA = Math.sqrt(Math.pow(starting_point_x - coords_motor_A[0], 2) + Math.pow(starting_point_y - coords_motor_A[1], 2));
        lengthB = Math.sqrt(Math.pow(starting_point_x - coords_motor_B[0], 2) + Math.pow(starting_point_y - coords_motor_B[1], 2));
        let [c_x, c_y] = calculateEndPoint(lengthA, lengthB);
    }

    /**
    * Updates the animation speed based on the slider value.
    * Adjusts speed value and ensures it stays within defined limits.
    * 
    * @returns {Promise<void>} Waits for GUI refresh.
    */
    async function get_slider_speed() {
        acc_sleep = 0; //reset acculumated sleep time
        if (parseFloat(speed_slider.value) > 100) {
            speed_slider.value = 105;
            speed_value.textContent = '\u221E'; // Unicode for infty
            animSpeed = Infinity;
        } else if (parseFloat(speed_slider.value) <= 1) {
            speed_slider.value = 1;
            speed_value.textContent = 1;
            animSpeed = 1;
        } else {
            speed_value.textContent = speed_slider.value;
            animSpeed = speed_slider.value;
        }
        await sleep(100); //wait for GUI to refresh in case of too speedy
    }

    /**
    * Resizes the canvas elements based on the input width and height.
    * Adjusts drawing area and motor coordinates accordingly.
    * 
    * @throws {Error} If the input values for width or height are invalid.
    */
    function resizeCanvas() {
        CANVASWIDTH = parseFloat(width_entry.value);
        CANVASHEIGHT = parseFloat(heigth_entry.value);

        //check for correct number format
        if (isNaN(CANVASWIDTH) || isNaN(CANVASHEIGHT)) {
            handleError("Invalid input of size");
        }

        gridCanvas.width = CANVASWIDTH;
        gridCanvas.height = CANVASHEIGHT;
        bgCanvas.width = CANVASWIDTH;
        bgCanvas.height = CANVASHEIGHT;
        fgCanvas.width = CANVASWIDTH;
        fgCanvas.height = CANVASHEIGHT;    

        OFFSET_X = CANVASWIDTH * offset_x_ratio; //for drawing area
        OFFSET_Y = CANVASHEIGHT * offset_y_ratio; //for drawing area
        WIDTH_DRAWINGAREA = CANVASWIDTH * drawingWidth_ratio; 
        HEIGHT_DRAWINGAREA = CANVASHEIGHT * drawingHeight_ratio; 
        coords_motor_A = [0, 0];
        coords_motor_B = [CANVASWIDTH, 0];
    }

    /**
    * Resizes the drawing area based on the input width and height.
    * Adjusts the motor coordinates and calculates new lengths accordingly.
    * 
    * @throws {Error} If the input values for width or height are invalid.
    */
    function resizeDrawingArea() {
        WIDTH_DRAWINGAREA = parseFloat(drawwidth_entry.value); 
        HEIGHT_DRAWINGAREA = parseFloat(drawheight_entry.value); 

        //check for correct number format
        if (isNaN(WIDTH_DRAWINGAREA) || isNaN(HEIGHT_DRAWINGAREA)) {
            handleError("Invalid input of size");
        }

        //calc new vars
        const dist_toBot = 40;
        OFFSET_X = (CANVASWIDTH-WIDTH_DRAWINGAREA)/2;
        OFFSET_Y = (CANVASHEIGHT-HEIGHT_DRAWINGAREA)-dist_toBot;
        lengthA = Math.sqrt(Math.pow(OFFSET_X, 2) + Math.pow(OFFSET_Y, 2));
        lengthB = Math.sqrt(Math.pow(CANVASWIDTH-OFFSET_X, 2) + Math.pow(OFFSET_Y, 2));
    }

    /**
    * Initializes the canvas, resets variables, and sets up the starting point and drawing area.
    * Clears the previous drawings and prepares for a new iteration.
    */
    function init() {
        //reset vars
        remainder = 0;
        /*##transfer commented out##
        transferA = 0;
        transferB = 0; */
        iter_count = 0;
        pixels = [];
        cur_iter.textContent = "(not started)";
        error_logger.textContent = "No errors so far";

        //clear Canvas
        bg_ctx.clearRect(0, 0, CANVASWIDTH, CANVASHEIGHT);
        fg_ctx.clearRect(0, 0, CANVASWIDTH, CANVASHEIGHT);
        grid_ctx.clearRect(0, 0, CANVASWIDTH, CANVASHEIGHT);

        //call methods
        resizeCanvas(); //resize canvas if wanted
        resizeDrawingArea(); //resize drawingArea if wanted
        set_startingPoint(); //set to topLeft of drawArea + reset lengths

        [c_x, c_y] = calculateEndPoint(lengthA, lengthB);
        drawForeground(c_x, c_y);
        hide_grid();
    }

    /**
    * Starts the drawing process, updates the drawing with the given sequences, and calculates the error.
    * Disables the start button during execution and logs the time and position details at the end.
    */
    async function start() {
        reset();
        start_button.disabled = true;
        running = true;
        pause = false;
    
        let startEnd_color = "rgba(128, 0, 128, 0)";
        let draw_color = "rgba(120 120, 120, 1)";
        startTime = Date.now();
        await update(to_drawStart, startEnd_color);
        let pos_drawStart = [c_x, c_y];
        await update(ANGLES, );
        let pos_drawEnd = [c_x, c_y];
        await update(to_begin, startEnd_color);
        let pos_end = [c_x, c_y];
        endTime = Date.now();
        let error = Math.sqrt((Math.pow(pos_end[0]-OFFSET_X,2)) + (Math.pow(pos_end[1]-OFFSET_Y,2)));
        
        cur_iter.textContent += " (finished)";

        console.log(`
            SUMMARY:
            Total needed time: ${endTime - startTime}ms
            Position of DrawStart: x=${pos_drawStart[0].toFixed(2)}; y=${pos_drawStart[1].toFixed(2)}
            Position of DrawEnd: x=${pos_drawEnd[0].toFixed(2)}; y=${pos_drawEnd[1].toFixed(2)}
            Position of Start: x=${OFFSET_X.toFixed(2)}; y=${OFFSET_Y.toFixed(2)}
            Position of End: x=${pos_end[0].toFixed(2)}; y=${pos_end[1].toFixed(2)}
            Error = ${error.toFixed(2)}mm
        `);

        mod_counter = 0;
        start_button.disabled = false;
    }

    /**
    * Resets the state by stopping the running process, re-enabling the start button and slider,
    * and reinitializing the canvas and settings.
    */
    function reset() {
        running = false;
        start_button.disabled = false;
        dcoil_slider.disabled = false;
        init();
    }
    
    /**
    * Toggles the pause state of the process.
    */
    function resume() {
        pause = !pause;
    }

    // --------------------event listeners----------------------
    file_checkbox.addEventListener("change", config_Angles);
    pre1_checkbox.addEventListener("change", config_Angles);
    pre2_checkbox.addEventListener("change", config_Angles);
    fileInput.addEventListener("change", load_File);
    hide_fg_checkbox.addEventListener("change", hide_fg);
    hide_grid_checkbox.addEventListener("change", hide_grid);
    dcoil_slider.addEventListener('input', get_slider_dcoil);
    speed_slider.addEventListener('input', get_slider_speed);
    
    /**
    * Listens for input on the width_entry field and updates canvas dimensions and related values.
    */
    width_entry.addEventListener('input', function() {
        resizeCanvas();
        //override other corresponding values
        drawwidth_entry.value = WIDTH_DRAWINGAREA;
        drawheight_entry.value = HEIGHT_DRAWINGAREA;
        starting_point_x_entry.value = OFFSET_X;
        starting_point_y_entry.value = OFFSET_Y;
        init();
    });

    /**
    * Listens for input on the heigth_entry field and updates canvas dimensions and related values.
    */
    heigth_entry.addEventListener('input', function() {
        resizeCanvas();
        //override other corresponding values
        drawwidth_entry.value = WIDTH_DRAWINGAREA;
        drawheight_entry.value = HEIGHT_DRAWINGAREA;
        starting_point_x_entry.value = OFFSET_X;
        starting_point_y_entry.value = OFFSET_Y;
        init();
    });

    /**
    * Listens for input on the drawwidth_entry field and updates drawing area dimensions and related values.
    */
    drawwidth_entry.addEventListener('input', function() {
        resizeDrawingArea();
        //override other corresponding values
        starting_point_x_entry.value = OFFSET_X;
        starting_point_y_entry.value = OFFSET_Y;
        init();
    });

    /**
    * Listens for input on the drawheight_entry field and updates drawing area dimensions and related values.
    */
    drawheight_entry.addEventListener('input', function() {
        resizeDrawingArea();
        //override other corresponding values
        starting_point_x_entry.value = OFFSET_X;
        starting_point_y_entry.value = OFFSET_Y;
        init();
    });

    /**
    * Listens for input on the starting_point_x_entry field and reinitializes.
    */
    starting_point_x_entry.addEventListener('input', function() {
        init();
    });

    /**
    * Listens for input on the starting_point_y_entry field and reinitializes.
    */
    starting_point_y_entry.addEventListener('input', function() {
        init();
    });

    /**
    * Listens for specific key presses and triggers corresponding actions:
    * - Space: Pauses or resumes the process.
    * - 'd': Increases the speed by one step.
    * - 'a': Decreases the speed by one step.
    * - 'w': Sets the speed to the maximum value.
    * - 's': Sets the speed to the minimum value.
    * - Escape: Resets the process.
    */
    document.addEventListener("keydown", (event) => {
        switch (event.key) {
            case " ":
                //console.log("leer gedrückt, runnung: ", running);
                //if (running) {
                    pause_button.click();
                //} else {
                    //start_button.click();
                //}
                event.preventDefault(); // Verhindert Scrollen der Seite
                
                break;
            case 'd':
                speed_slider.value = parseFloat(speed_slider.value) + parseFloat(speed_slider.step);
                get_slider_speed();
                break;
            case 'a':
                speed_slider.value = parseFloat(speed_slider.value) - parseFloat(speed_slider.step);
                get_slider_speed();
                break;
            case 'w':
                speed_slider.value = speed_slider.max;
                get_slider_speed();
                break;
            case 's':
                speed_slider.value = speed_slider.min;
                get_slider_speed();
                break;
            case 'Escape':
                reset();
                break;
        }
    });
    
    /**
    * Initializes the settings after the DOM is loaded:
    * - Sets default values for checkboxes, sliders, and input fields.
    * - Configures angles, coil slider, and speed slider.
    * - Calls the `init` function to initialize the canvas and other elements.
    */
    document.addEventListener('DOMContentLoaded', () => {
        file_checkbox.checked = true;
        dcoil_slider.value = 16;
        speed_slider.value = 50;
        width_entry.value = 1910;
        heigth_entry.value = 965;
        drawwidth_entry.value = 1280;
        drawheight_entry.value = 720;
        starting_point_x_entry.value = 315;
        starting_point_y_entry.value = 205;

        config_Angles();
        get_slider_dcoil();
        get_slider_speed();

        init();
    });

    </script>
</body>
</html>